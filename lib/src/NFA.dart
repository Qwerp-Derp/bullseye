import "Node.dart";
import "Methods.dart";

String EPSILON = "";

/// The main class for the non-determinstic automaton
/// generated by Thompson's algorithm.
class NFA {
  List regex_groups;
  List<Node> nodes;
  int node_index;
  int ending_node;

  /// Connects two nodes together, according to the rules of
  /// Thompson's Construction Algorithm.
  void _connectNode(List group, Node start, Node end) {
    int temp_index = this.node_index;

    if (group[0] == "STAR") {
      this.node_index += 2;
      Node left = new Node(temp_index);
      Node right = new Node(temp_index + 1);

      this._connectNode(group[1], left, right);

      start.addPath(EPSILON, left);
      start.addPath(EPSILON, end);
      right.addPath(EPSILON, left);
      right.addPath(EPSILON, end);

      this.nodes.addAll([left, right]);
    } else if (group[0] == "PLUS") {
      this.node_index += 2;
      Node left = new Node(temp_index);
      Node right = new Node(temp_index + 1);

      this._connectNode(group[1], left, right);

      start.addPath(EPSILON, left);
      right.addPath(EPSILON, left);
      right.addPath(EPSILON, end);

      this.nodes.addAll([left, right]);
    } else if (group[0] == "QMARK") {
      this._connectNode(group[1], start, end);

      start.addPath(EPSILON, end);
    } else if (group[0] == "OR") {
      List connected_groups = group.sublist(1);
      this.node_index += connected_groups.length * 2;

      for (int a = 0; a < connected_groups.length; a++) {
        Node group_start = new Node(temp_index + (2 * a));
        Node group_end = new Node(temp_index + (2 * a) + 1);

        this._connectNode(connected_groups[a], group_start, group_end);

        start.addPath(EPSILON, group_start);
        group_end.addPath(EPSILON, end);

        this.nodes.addAll([group_start, group_end]);
      }
    } else if (group[0] == "GROUP") {
      List items = group[1];
      List<Node> group_nodes = [start];
      this.node_index += items.length - 1;

      for (int a = 0; a < items.length - 1; a++) {
        Node new_node = new Node(temp_index + a);

        this._connectNode(items[a], group_nodes[a], new_node);

        group_nodes.add(new_node);
      }

      this._connectNode(
          items[items.length - 1], group_nodes[group_nodes.length - 1], end);
      this.nodes.addAll(group_nodes.sublist(1));
    } else if (group[0] == "CHAR") {
      start.addPath(group[1], end);
    }
  }

  /// Parses the final regex.
  void _parseRegex() {
    int starting_index = 0;

    for (int a = 0; a < this.regex_groups.length; a++) {
      List current_group = this.regex_groups[a];

      Node temp_node = new Node(this.node_index);
      this.ending_node = this.node_index;
      this.node_index += 1;

      this._connectNode(current_group, this.nodes[starting_index], temp_node);

      this.nodes.add(temp_node);
      starting_index = this.nodes.length - 1;
    }

    this.nodes.sort((first, second) => first.ident - second.ident);
  }

  /// Constructor class for the NFA.
  NFA(List regex_groups) {
    this.regex_groups = regex_groups;
    this.nodes = [new Node(0)];
    this.node_index = 1;

    this._parseRegex();
  }
}

void main() {
  NFA test = new NFA(tokeniseRegex("a+"));

  for (int a = 0; a < test.nodes.length; a++)
    print("${test.nodes[a].ident}, ${test.nodes[a].paths}");
}
